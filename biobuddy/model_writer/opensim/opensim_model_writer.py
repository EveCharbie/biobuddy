from time import strftime
from lxml import etree
import numpy as np

from ...components.real.biomechanical_model_real import BiomechanicalModelReal
from ...utils.enums import Translations, Rotations
from ...utils.linear_algebra import rot2eul


class OpensimModelWriter:
    def __init__(self, filepath: str, with_mesh: bool = False):
        """
        The path where the model should be printed

        Parameters
        ----------
        filepath
            The path to the model to write
        with_mesh
            If the mesh files should be added to the model to write
        """
        self.filepath = filepath
        self.with_mesh = with_mesh

    def write(self, model: BiomechanicalModelReal) -> None:
        """
        Write the OpenSim model to file

        Parameters
        ----------
        model
            The biomechanical model to write
        """
        root = etree.Element("OpenSimDocument", Version="40000")
        model_elem = etree.SubElement(root, "Model", name="model")
        
        self._write_credits(model_elem, model)
        self._write_units(model_elem)
        self._write_gravity(model_elem, model)
        self._write_ground(model_elem, model)
        self._write_body_set(model_elem, model)
        self._write_joint_set(model_elem, model)
        self._write_marker_set(model_elem, model)
        self._write_force_set(model_elem, model)
        
        tree = etree.ElementTree(root)
        tree.write(self.filepath, pretty_print=True, xml_declaration=True, encoding='UTF-8')

    def _write_credits(self, model_elem: etree.Element, model: BiomechanicalModelReal):
        """Write credits and publication information"""
        credits = etree.SubElement(model_elem, "credits")
        credits.text = f"Generated by BioBuddy on {strftime('%Y-%m-%d %H:%M:%S')}"
        
        publications = etree.SubElement(model_elem, "publications")
        publications.text = "BioBuddy - Biomechanical Model Builder"

    def _write_units(self, model_elem: etree.Element):
        """Write unit information"""
        length_units = etree.SubElement(model_elem, "length_units")
        length_units.text = "meters"
        
        force_units = etree.SubElement(model_elem, "force_units")
        force_units.text = "N"

    def _write_gravity(self, model_elem: etree.Element, model: BiomechanicalModelReal):
        """Write gravity vector"""
        gravity_elem = etree.SubElement(model_elem, "gravity")
        if model.gravity is not None:
            g = model.gravity[:3]
            gravity_elem.text = f"{g[0]:.8f} {g[1]:.8f} {g[2]:.8f}"
        else:
            gravity_elem.text = "0 -9.80665 0"

    def _write_ground(self, model_elem: etree.Element, model: BiomechanicalModelReal):
        """Write ground body"""
        ground = etree.SubElement(model_elem, "ground")
        
        if "ground" in model.segment_names:
            ground_segment = model.segments["ground"]
            
            if ground_segment.nb_markers > 0:
                attached_geometry = etree.SubElement(ground, "attached_geometry")
                for marker in ground_segment.markers:
                    # TODO: Add marker.to_osim() method to MarkerReal
                    marker_elem = self._create_marker_element(marker)
                    attached_geometry.append(marker_elem)

    def _write_body_set(self, model_elem: etree.Element, model: BiomechanicalModelReal):
        """Write all body segments"""
        body_set = etree.SubElement(model_elem, "BodySet")
        objects = etree.SubElement(body_set, "objects")
        
        for segment in model.segments:
            if segment.name == "ground" or segment.name == "base":
                continue
            
            # Skip virtual segments used for coordinate transformations
            if self._is_virtual_segment(segment):
                continue
            
            # TODO: Add segment.to_osim() method to SegmentReal
            body_elem = self._create_body_element(segment)
            objects.append(body_elem)

    def _create_body_element(self, segment):
        """Create a Body element from a segment"""
        body_elem = etree.Element("Body", name=segment.name)
        
        if segment.inertia_parameters is not None:
            mass_elem = etree.SubElement(body_elem, "mass")
            mass_elem.text = f"{segment.inertia_parameters.mass:.8f}"
            
            com = np.nanmean(segment.inertia_parameters.center_of_mass, axis=1)[:3]
            mass_center_elem = etree.SubElement(body_elem, "mass_center")
            mass_center_elem.text = f"{com[0]:.8f} {com[1]:.8f} {com[2]:.8f}"
            
            inertia_elem = etree.SubElement(body_elem, "inertia")
            i = segment.inertia_parameters.inertia
            inertia_elem.text = f"{i[0,0]:.8f} {i[1,1]:.8f} {i[2,2]:.8f} {i[0,1]:.8f} {i[0,2]:.8f} {i[1,2]:.8f}"
        
        if self.with_mesh and segment.mesh_file is not None:
            frame_geometry = etree.SubElement(body_elem, "FrameGeometry")
            socket_frame = etree.SubElement(frame_geometry, "socket_frame")
            socket_frame.text = ".."
            
            attached_geometry = etree.SubElement(body_elem, "attached_geometry")
            mesh_elem = etree.SubElement(attached_geometry, "Mesh", name=f"{segment.name}_mesh")
            
            mesh_file_elem = etree.SubElement(mesh_elem, "mesh_file")
            mesh_file_elem.text = segment.mesh_file.mesh_file_name
            
            if segment.mesh_file.mesh_scale is not None:
                scale_factors = etree.SubElement(mesh_elem, "scale_factors")
                s = segment.mesh_file.mesh_scale
                scale_factors.text = f"{s[0,0]:.8f} {s[1,0]:.8f} {s[2,0]:.8f}"
            
            if segment.mesh_file.mesh_color is not None:
                appearance = etree.SubElement(mesh_elem, "Appearance")
                color_elem = etree.SubElement(appearance, "color")
                c = segment.mesh_file.mesh_color
                color_elem.text = f"{c[0]:.8f} {c[1]:.8f} {c[2]:.8f}"
        
        return body_elem

    def _write_joint_set(self, model_elem: etree.Element, model: BiomechanicalModelReal):
        """Write all joints"""
        joint_set = etree.SubElement(model_elem, "JointSet")
        objects = etree.SubElement(joint_set, "objects")
        
        for segment in model.segments:
            if segment.name == "ground" or segment.name == "base":
                continue
            
            # Skip virtual segments
            if self._is_virtual_segment(segment):
                continue
            
            parent_name = segment.parent_name if segment.parent_name != "base" else "ground"
            
            # Handle virtual parent segments by finding the real parent
            while parent_name in model.segment_names and self._is_virtual_segment(model.segments[parent_name]):
                parent_name = model.segments[parent_name].parent_name
                if parent_name == "base":
                    parent_name = "ground"
                    break
            
            if segment.nb_q > 0:
                joint_elem = self._create_custom_joint(segment, parent_name, model)
            else:
                joint_elem = self._create_weld_joint(segment, parent_name)
            
            objects.append(joint_elem)

    def _create_weld_joint(self, segment, parent_name: str):
        """Create a WeldJoint (no DOFs)"""
        joint = etree.Element("WeldJoint", name=f"{segment.name}_joint")
        
        socket_parent = etree.SubElement(joint, "socket_parent_frame")
        socket_parent.text = f"../{parent_name}"
        
        socket_child = etree.SubElement(joint, "socket_child_frame")
        socket_child.text = f"../{segment.name}"
        
        frames = etree.SubElement(joint, "frames")
        
        # Parent offset frame
        parent_frame = etree.SubElement(frames, "PhysicalOffsetFrame", name=f"{parent_name}_offset")
        parent_socket = etree.SubElement(parent_frame, "socket_parent")
        parent_socket.text = f"../{parent_name}"
        
        rt = segment.segment_coordinate_system.scs.rt_matrix
        translation = etree.SubElement(parent_frame, "translation")
        translation.text = f"{rt[0,3]:.8f} {rt[1,3]:.8f} {rt[2,3]:.8f}"
        
        angles = rot2eul(rt[:3, :3])
        orientation = etree.SubElement(parent_frame, "orientation")
        orientation.text = f"{angles[0]:.8f} {angles[1]:.8f} {angles[2]:.8f}"
        
        # Child offset frame
        child_frame = etree.SubElement(frames, "PhysicalOffsetFrame", name=f"{segment.name}_offset")
        child_socket = etree.SubElement(child_frame, "socket_parent")
        child_socket.text = f"../{segment.name}"
        
        child_translation = etree.SubElement(child_frame, "translation")
        child_translation.text = "0 0 0"
        
        child_orientation = etree.SubElement(child_frame, "orientation")
        child_orientation.text = "0 0 0"
        
        return joint

    def _create_custom_joint(self, segment, parent_name: str, model: BiomechanicalModelReal):
        """Create a CustomJoint with DOFs"""
        joint = etree.Element("CustomJoint", name=f"{segment.name}_joint")
        
        socket_parent = etree.SubElement(joint, "socket_parent_frame")
        socket_parent.text = f"../{parent_name}"
        
        socket_child = etree.SubElement(joint, "socket_child_frame")
        socket_child.text = f"../{segment.name}"
        
        frames = etree.SubElement(joint, "frames")
        
        # Parent offset frame
        parent_frame = etree.SubElement(frames, "PhysicalOffsetFrame", name=f"{parent_name}_offset")
        parent_socket = etree.SubElement(parent_frame, "socket_parent")
        parent_socket.text = f"../{parent_name}"
        
        rt = segment.segment_coordinate_system.scs.rt_matrix
        translation = etree.SubElement(parent_frame, "translation")
        translation.text = f"{rt[0,3]:.8f} {rt[1,3]:.8f} {rt[2,3]:.8f}"
        
        angles = rot2eul(rt[:3, :3])
        orientation = etree.SubElement(parent_frame, "orientation")
        orientation.text = f"{angles[0]:.8f} {angles[1]:.8f} {angles[2]:.8f}"
        
        # Child offset frame
        child_frame = etree.SubElement(frames, "PhysicalOffsetFrame", name=f"{segment.name}_offset")
        child_socket = etree.SubElement(child_frame, "socket_parent")
        child_socket.text = f"../{segment.name}"
        
        child_translation = etree.SubElement(child_frame, "translation")
        child_translation.text = "0 0 0"
        
        child_orientation = etree.SubElement(child_frame, "orientation")
        child_orientation.text = "0 0 0"
        
        # Spatial transform
        spatial_transform = etree.SubElement(joint, "SpatialTransform")
        
        dof_counter = 0
        
        # Rotations (first 3 transform axes)
        for i, axis_name in enumerate(['X', 'Y', 'Z']):
            transform_axis = etree.SubElement(spatial_transform, "TransformAxis", name=f"rotation{i+1}")
            
            axis_elem = etree.SubElement(transform_axis, "axis")
            axis_vector = [0, 0, 0]
            axis_vector[i] = 1
            axis_elem.text = f"{axis_vector[0]} {axis_vector[1]} {axis_vector[2]}"
            
            if segment.rotations != Rotations.NONE and axis_name.lower() in segment.rotations.value:
                coord_name = segment.dof_names[dof_counter]
                dof_counter += 1
                
                coordinates = etree.SubElement(transform_axis, "coordinates")
                coord_elem = etree.SubElement(coordinates, "Coordinate", name=coord_name)
                
                default_value = etree.SubElement(coord_elem, "default_value")
                default_value.text = "0"
                
                if segment.q_ranges is not None:
                    idx = segment.dof_names.index(coord_name)
                    range_elem = etree.SubElement(coord_elem, "range")
                    range_elem.text = f"{segment.q_ranges.min_bound[idx]:.8f} {segment.q_ranges.max_bound[idx]:.8f}"
                    
                    clamped = etree.SubElement(coord_elem, "clamped")
                    clamped.text = "false"
                
                locked = etree.SubElement(coord_elem, "locked")
                locked.text = "false"
            else:
                function = etree.SubElement(transform_axis, "function")
                constant = etree.SubElement(function, "Constant")
                value = etree.SubElement(constant, "value")
                value.text = "0"
        
        # Translations (last 3 transform axes)
        for i, axis_name in enumerate(['X', 'Y', 'Z']):
            transform_axis = etree.SubElement(spatial_transform, "TransformAxis", name=f"translation{i+1}")
            
            axis_elem = etree.SubElement(transform_axis, "axis")
            axis_vector = [0, 0, 0]
            axis_vector[i] = 1
            axis_elem.text = f"{axis_vector[0]} {axis_vector[1]} {axis_vector[2]}"
            
            if segment.translations != Translations.NONE and axis_name.lower() in segment.translations.value:
                coord_name = segment.dof_names[dof_counter]
                dof_counter += 1
                
                coordinates = etree.SubElement(transform_axis, "coordinates")
                coord_elem = etree.SubElement(coordinates, "Coordinate", name=coord_name)
                
                default_value = etree.SubElement(coord_elem, "default_value")
                default_value.text = "0"
                
                if segment.q_ranges is not None:
                    idx = segment.dof_names.index(coord_name)
                    range_elem = etree.SubElement(coord_elem, "range")
                    range_elem.text = f"{segment.q_ranges.min_bound[idx]:.8f} {segment.q_ranges.max_bound[idx]:.8f}"
                    
                    clamped = etree.SubElement(coord_elem, "clamped")
                    clamped.text = "false"
                
                locked = etree.SubElement(coord_elem, "locked")
                locked.text = "false"
            else:
                function = etree.SubElement(transform_axis, "function")
                constant = etree.SubElement(function, "Constant")
                value = etree.SubElement(constant, "value")
                value.text = "0"
        
        return joint

    def _write_marker_set(self, model_elem: etree.Element, model: BiomechanicalModelReal):
        """Write all markers"""
        marker_set = etree.SubElement(model_elem, "MarkerSet")
        objects = etree.SubElement(marker_set, "objects")
        
        for segment in model.segments:
            if segment.name == "ground":
                continue
            
            # Skip virtual segments
            if self._is_virtual_segment(segment):
                continue
            
            for marker in segment.markers:
                # TODO: Add marker.to_osim() method to MarkerReal
                marker_elem = self._create_marker_element(marker)
                objects.append(marker_elem)

    def _create_marker_element(self, marker):
        """Create a Marker element"""
        p = marker.mean_position
        marker_elem = etree.Element("Marker", name=marker.name)
        
        socket_parent = etree.SubElement(marker_elem, "socket_parent_frame")
        socket_parent.text = f"../{marker.parent_name}"
        
        location = etree.SubElement(marker_elem, "location")
        location.text = f"{p[0]:.8f} {p[1]:.8f} {p[2]:.8f}"
        
        fixed = etree.SubElement(marker_elem, "fixed")
        fixed.text = "false"
        
        return marker_elem

    def _write_force_set(self, model_elem: etree.Element, model: BiomechanicalModelReal):
        """Write all muscles"""
        force_set = etree.SubElement(model_elem, "ForceSet")
        objects = etree.SubElement(force_set, "objects")
        
        for muscle_group in model.muscle_groups:
            for muscle in muscle_group.muscles:
                # TODO: Add muscle.to_osim() method to MuscleReal
                muscle_elem = self._create_muscle_element(muscle, muscle_group)
                objects.append(muscle_elem)

    def _create_muscle_element(self, muscle, muscle_group):
        """Create a muscle element"""
        muscle_elem = etree.Element("DeGrooteFregly2016Muscle", name=muscle.name)
        
        max_iso_force = etree.SubElement(muscle_elem, "max_isometric_force")
        max_iso_force.text = f"{muscle.maximal_force:.8f}"
        
        opt_fiber_length = etree.SubElement(muscle_elem, "optimal_fiber_length")
        opt_fiber_length.text = f"{muscle.optimal_length:.8f}" if muscle.optimal_length else "0.1"
        
        tendon_slack = etree.SubElement(muscle_elem, "tendon_slack_length")
        tendon_slack.text = f"{muscle.tendon_slack_length:.8f}" if muscle.tendon_slack_length else "0.2"
        
        pennation = etree.SubElement(muscle_elem, "pennation_angle_at_optimal")
        pennation.text = f"{muscle.pennation_angle:.8f}" if muscle.pennation_angle else "0"
        
        max_velocity = etree.SubElement(muscle_elem, "max_contraction_velocity")
        max_velocity.text = f"{muscle.maximal_velocity:.8f}" if muscle.maximal_velocity else "10"
        
        # Geometry path
        geometry_path = etree.SubElement(muscle_elem, "GeometryPath")
        path_point_set = etree.SubElement(geometry_path, "PathPointSet")
        path_objects = etree.SubElement(path_point_set, "objects")
        
        # Origin
        origin_elem = etree.SubElement(path_objects, "PathPoint", name=f"{muscle.name}_origin")
        origin_socket = etree.SubElement(origin_elem, "socket_parent_frame")
        origin_socket.text = f"../{muscle.origin_position.parent_name}"
        origin_location = etree.SubElement(origin_elem, "location")
        p = muscle.origin_position.position
        origin_location.text = f"{p[0,0]:.8f} {p[1,0]:.8f} {p[2,0]:.8f}"
        
        # Via points
        for via_point in muscle.via_points:
            # TODO: Handle conditional and moving via points
            if via_point.condition is not None or via_point.movement is not None:
                # For now, skip conditional and moving via points
                # These require ConditionalPathPoint or MovingPathPoint elements
                continue
            
            via_elem = etree.SubElement(path_objects, "PathPoint", name=via_point.name)
            via_socket = etree.SubElement(via_elem, "socket_parent_frame")
            via_socket.text = f"../{via_point.parent_name}"
            via_location = etree.SubElement(via_elem, "location")
            p = via_point.position
            via_location.text = f"{p[0,0]:.8f} {p[1,0]:.8f} {p[2,0]:.8f}"
        
        # Insertion
        insertion_elem = etree.SubElement(path_objects, "PathPoint", name=f"{muscle.name}_insertion")
        insertion_socket = etree.SubElement(insertion_elem, "socket_parent_frame")
        insertion_socket.text = f"../{muscle.insertion_position.parent_name}"
        insertion_location = etree.SubElement(insertion_elem, "location")
        p = muscle.insertion_position.position
        insertion_location.text = f"{p[0,0]:.8f} {p[1,0]:.8f} {p[2,0]:.8f}"
        
        return muscle_elem

    def _is_virtual_segment(self, segment) -> bool:
        """Check if a segment is virtual (used for coordinate transformations)"""
        virtual_suffixes = ["_parent_offset", "_translation", "_rotation_transform", "_reset_axis"]
        return any(segment.name.endswith(suffix) for suffix in virtual_suffixes)
